{
  "ast": null,
  "code": "'use strict';\n/**\n * Polyfill for `endsWith`\n *\n * @param {string} str\n * @param {string} pattern\n * @return {boolean}\n */\n\nfunction endsWith(str, pattern) {\n  return str.lastIndexOf(pattern) === str.length - pattern.length;\n}\n/**\n * Check if `vhost` is a valid suffix of `hostname` (top-domain)\n *\n * It means that `vhost` needs to be a suffix of `hostname` and we then need to\n * make sure that: either they are equal, or the character preceding `vhost` in\n * `hostname` is a '.' (it should not be a partial label).\n *\n * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok\n * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok\n * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok\n *\n * @param {string} hostname\n * @param {string} vhost\n * @return {boolean}\n */\n\n\nfunction shareSameDomainSuffix(hostname, vhost) {\n  if (endsWith(hostname, vhost)) {\n    return hostname.length === vhost.length || hostname[hostname.length - vhost.length - 1] === '.';\n  }\n\n  return false;\n}\n/**\n * Given a hostname and its public suffix, extract the general domain.\n *\n *  @param {string} hostname\n *  @param {string} publicSuffix\n *  @return {string}\n */\n\n\nfunction extractDomainWithSuffix(hostname, publicSuffix) {\n  // Locate the index of the last '.' in the part of the `hostname` preceding\n  // the public suffix.\n  //\n  // examples:\n  //   1. not.evil.co.uk  => evil.co.uk\n  //         ^    ^\n  //         |    | start of public suffix\n  //         | index of the last dot\n  //\n  //   2. example.co.uk   => example.co.uk\n  //     ^       ^\n  //     |       | start of public suffix\n  //     |\n  //     | (-1) no dot found before the public suffix\n  var publicSuffixIndex = hostname.length - publicSuffix.length - 2;\n  var lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex); // No '.' found, then `hostname` is the general domain (no sub-domain)\n\n  if (lastDotBeforeSuffixIndex === -1) {\n    return hostname;\n  } // Extract the part between the last '.'\n\n\n  return hostname.substr(lastDotBeforeSuffixIndex + 1);\n}\n/**\n * Detects the domain based on rules and upon and a host string\n *\n * @api\n * @param {string} host\n * @return {String}\n */\n\n\nmodule.exports = function getDomain(validHosts, suffix, hostname) {\n  // Check if `hostname` ends with a member of `validHosts`.\n  for (var i = 0; i < validHosts.length; i += 1) {\n    var vhost = validHosts[i];\n\n    if (shareSameDomainSuffix(hostname, vhost)) {\n      return vhost;\n    }\n  } // If there is no suffix, there is no hostname\n\n\n  if (suffix === null) {\n    return null;\n  } // If `hostname` is a valid public suffix, then there is no domain to return.\n  // Since we already know that `getPublicSuffix` returns a suffix of `hostname`\n  // there is no need to perform a string comparison and we only compare the\n  // size.\n\n\n  if (suffix.length === hostname.length) {\n    return null;\n  } // To extract the general domain, we start by identifying the public suffix\n  // (if any), then consider the domain to be the public suffix with one added\n  // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:\n  // `co.uk`, then we take one more level: `evil`, giving the final result:\n  // `evil.co.uk`).\n\n\n  return extractDomainWithSuffix(hostname, suffix);\n};",
  "map": {
    "version": 3,
    "names": [
      "endsWith",
      "str",
      "pattern",
      "lastIndexOf",
      "length",
      "shareSameDomainSuffix",
      "hostname",
      "vhost",
      "extractDomainWithSuffix",
      "publicSuffix",
      "publicSuffixIndex",
      "lastDotBeforeSuffixIndex",
      "substr",
      "module",
      "exports",
      "getDomain",
      "validHosts",
      "suffix",
      "i"
    ],
    "sources": ["/Users/danielleflinn/Documents/GitHub/clients/node_modules/tldjs/lib/domain.js"],
    "sourcesContent": [
      "'use strict';\n\n\n/**\n * Polyfill for `endsWith`\n *\n * @param {string} str\n * @param {string} pattern\n * @return {boolean}\n */\nfunction endsWith(str, pattern) {\n  return (\n    str.lastIndexOf(pattern) === (str.length - pattern.length)\n  );\n}\n\n\n/**\n * Check if `vhost` is a valid suffix of `hostname` (top-domain)\n *\n * It means that `vhost` needs to be a suffix of `hostname` and we then need to\n * make sure that: either they are equal, or the character preceding `vhost` in\n * `hostname` is a '.' (it should not be a partial label).\n *\n * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok\n * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok\n * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok\n *\n * @param {string} hostname\n * @param {string} vhost\n * @return {boolean}\n */\nfunction shareSameDomainSuffix(hostname, vhost) {\n  if (endsWith(hostname, vhost)) {\n    return (\n      hostname.length === vhost.length ||\n      hostname[hostname.length - vhost.length - 1] === '.'\n    );\n  }\n\n  return false;\n}\n\n\n/**\n * Given a hostname and its public suffix, extract the general domain.\n *\n *  @param {string} hostname\n *  @param {string} publicSuffix\n *  @return {string}\n */\nfunction extractDomainWithSuffix(hostname, publicSuffix) {\n  // Locate the index of the last '.' in the part of the `hostname` preceding\n  // the public suffix.\n  //\n  // examples:\n  //   1. not.evil.co.uk  => evil.co.uk\n  //         ^    ^\n  //         |    | start of public suffix\n  //         | index of the last dot\n  //\n  //   2. example.co.uk   => example.co.uk\n  //     ^       ^\n  //     |       | start of public suffix\n  //     |\n  //     | (-1) no dot found before the public suffix\n  var publicSuffixIndex = hostname.length - publicSuffix.length - 2;\n  var lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);\n\n  // No '.' found, then `hostname` is the general domain (no sub-domain)\n  if (lastDotBeforeSuffixIndex === -1) {\n    return hostname;\n  }\n\n  // Extract the part between the last '.'\n  return hostname.substr(lastDotBeforeSuffixIndex + 1);\n}\n\n\n/**\n * Detects the domain based on rules and upon and a host string\n *\n * @api\n * @param {string} host\n * @return {String}\n */\nmodule.exports = function getDomain(validHosts, suffix, hostname) {\n  // Check if `hostname` ends with a member of `validHosts`.\n  for (var i = 0; i < validHosts.length; i += 1) {\n    var vhost = validHosts[i];\n    if (shareSameDomainSuffix(hostname, vhost)) {\n      return vhost;\n    }\n  }\n\n  // If there is no suffix, there is no hostname\n  if (suffix === null) {\n    return null;\n  }\n\n  // If `hostname` is a valid public suffix, then there is no domain to return.\n  // Since we already know that `getPublicSuffix` returns a suffix of `hostname`\n  // there is no need to perform a string comparison and we only compare the\n  // size.\n  if (suffix.length === hostname.length) {\n    return null;\n  }\n\n  // To extract the general domain, we start by identifying the public suffix\n  // (if any), then consider the domain to be the public suffix with one added\n  // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:\n  // `co.uk`, then we take one more level: `evil`, giving the final result:\n  // `evil.co.uk`).\n  return extractDomainWithSuffix(hostname, suffix);\n};\n"
    ],
    "mappings": "AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,QAAT,CAAkBC,GAAlB,EAAuBC,OAAvB,EAAgC;EAC9B,OACED,GAAG,CAACE,WAAJ,CAAgBD,OAAhB,MAA8BD,GAAG,CAACG,MAAJ,GAAaF,OAAO,CAACE,MADrD;AAGD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,qBAAT,CAA+BC,QAA/B,EAAyCC,KAAzC,EAAgD;EAC9C,IAAIP,QAAQ,CAACM,QAAD,EAAWC,KAAX,CAAZ,EAA+B;IAC7B,OACED,QAAQ,CAACF,MAAT,KAAoBG,KAAK,CAACH,MAA1B,IACAE,QAAQ,CAACA,QAAQ,CAACF,MAAT,GAAkBG,KAAK,CAACH,MAAxB,GAAiC,CAAlC,CAAR,KAAiD,GAFnD;EAID;;EAED,OAAO,KAAP;AACD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,uBAAT,CAAiCF,QAAjC,EAA2CG,YAA3C,EAAyD;EACvD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAIC,iBAAiB,GAAGJ,QAAQ,CAACF,MAAT,GAAkBK,YAAY,CAACL,MAA/B,GAAwC,CAAhE;EACA,IAAIO,wBAAwB,GAAGL,QAAQ,CAACH,WAAT,CAAqB,GAArB,EAA0BO,iBAA1B,CAA/B,CAhBuD,CAkBvD;;EACA,IAAIC,wBAAwB,KAAK,CAAC,CAAlC,EAAqC;IACnC,OAAOL,QAAP;EACD,CArBsD,CAuBvD;;;EACA,OAAOA,QAAQ,CAACM,MAAT,CAAgBD,wBAAwB,GAAG,CAA3C,CAAP;AACD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAE,MAAM,CAACC,OAAP,GAAiB,SAASC,SAAT,CAAmBC,UAAnB,EAA+BC,MAA/B,EAAuCX,QAAvC,EAAiD;EAChE;EACA,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,UAAU,CAACZ,MAA/B,EAAuCc,CAAC,IAAI,CAA5C,EAA+C;IAC7C,IAAIX,KAAK,GAAGS,UAAU,CAACE,CAAD,CAAtB;;IACA,IAAIb,qBAAqB,CAACC,QAAD,EAAWC,KAAX,CAAzB,EAA4C;MAC1C,OAAOA,KAAP;IACD;EACF,CAP+D,CAShE;;;EACA,IAAIU,MAAM,KAAK,IAAf,EAAqB;IACnB,OAAO,IAAP;EACD,CAZ+D,CAchE;EACA;EACA;EACA;;;EACA,IAAIA,MAAM,CAACb,MAAP,KAAkBE,QAAQ,CAACF,MAA/B,EAAuC;IACrC,OAAO,IAAP;EACD,CApB+D,CAsBhE;EACA;EACA;EACA;EACA;;;EACA,OAAOI,uBAAuB,CAACF,QAAD,EAAWW,MAAX,CAA9B;AACD,CA5BD"
  },
  "metadata": {},
  "sourceType": "script"
}

{
  "ast": null,
  "code": "\"use strict\";\n\nvar VALID_HOSTNAME_VALUE = 0;\n/**\n * Return min(a, b), handling possible `null` values.\n *\n * @param {number|null} a\n * @param {number|null} b\n * @return {number|null}\n */\n\nfunction minIndex(a, b) {\n  if (a === null) {\n    return b;\n  } else if (b === null) {\n    return a;\n  }\n\n  return a < b ? a : b;\n}\n/**\n * Insert a public suffix rule in the `trie`.\n *\n * @param {object} rule\n * @param {object} trie\n * @return {object} trie (updated)\n */\n\n\nfunction insertInTrie(rule, trie) {\n  var parts = rule.parts;\n  var node = trie;\n\n  for (var i = 0; i < parts.length; i += 1) {\n    var part = parts[i];\n    var nextNode = node[part];\n\n    if (nextNode === undefined) {\n      nextNode = Object.create(null);\n      node[part] = nextNode;\n    }\n\n    node = nextNode;\n  }\n\n  node.$ = VALID_HOSTNAME_VALUE;\n  return trie;\n}\n/**\n * Recursive lookup of `parts` (starting at `index`) in the tree.\n *\n * @param {array} parts\n * @param {object} trie\n * @param {number} index - when to start in `parts` (initially: length - 1)\n * @return {number} size of the suffix found (in number of parts matched)\n */\n\n\nfunction lookupInTrie(parts, trie, index) {\n  var part;\n  var nextNode;\n  var publicSuffixIndex = null; // We have a match!\n\n  if (trie.$ !== undefined) {\n    publicSuffixIndex = index + 1;\n  } // No more `parts` to look for\n\n\n  if (index === -1) {\n    return publicSuffixIndex;\n  }\n\n  part = parts[index]; // Check branch corresponding to next part of hostname\n\n  nextNode = trie[part];\n\n  if (nextNode !== undefined) {\n    publicSuffixIndex = minIndex(publicSuffixIndex, lookupInTrie(parts, nextNode, index - 1));\n  } // Check wildcard branch\n\n\n  nextNode = trie['*'];\n\n  if (nextNode !== undefined) {\n    publicSuffixIndex = minIndex(publicSuffixIndex, lookupInTrie(parts, nextNode, index - 1));\n  }\n\n  return publicSuffixIndex;\n}\n/**\n * Contains the public suffix ruleset as a Trie for efficient look-up.\n *\n * @constructor\n */\n\n\nfunction SuffixTrie(rules) {\n  this.exceptions = Object.create(null);\n  this.rules = Object.create(null);\n\n  if (rules) {\n    for (var i = 0; i < rules.length; i += 1) {\n      var rule = rules[i];\n\n      if (rule.exception) {\n        insertInTrie(rule, this.exceptions);\n      } else {\n        insertInTrie(rule, this.rules);\n      }\n    }\n  }\n}\n/**\n * Load the trie from JSON (as serialized by JSON.stringify).\n */\n\n\nSuffixTrie.fromJson = function (json) {\n  var trie = new SuffixTrie();\n  trie.exceptions = json.exceptions;\n  trie.rules = json.rules;\n  return trie;\n};\n/**\n * Check if `value` is a valid TLD.\n */\n\n\nSuffixTrie.prototype.hasTld = function (value) {\n  // All TLDs are at the root of the Trie.\n  return this.rules[value] !== undefined;\n};\n/**\n * Check if `hostname` has a valid public suffix in `trie`.\n *\n * @param {string} hostname\n * @return {string|null} public suffix\n */\n\n\nSuffixTrie.prototype.suffixLookup = function (hostname) {\n  var parts = hostname.split('.'); // Look for a match in rules\n\n  var publicSuffixIndex = lookupInTrie(parts, this.rules, parts.length - 1);\n\n  if (publicSuffixIndex === null) {\n    return null;\n  } // Look for exceptions\n\n\n  var exceptionIndex = lookupInTrie(parts, this.exceptions, parts.length - 1);\n\n  if (exceptionIndex !== null) {\n    return parts.slice(exceptionIndex + 1).join('.');\n  }\n\n  return parts.slice(publicSuffixIndex).join('.');\n};\n\nmodule.exports = SuffixTrie;",
  "map": {
    "version": 3,
    "names": [
      "VALID_HOSTNAME_VALUE",
      "minIndex",
      "a",
      "b",
      "insertInTrie",
      "rule",
      "trie",
      "parts",
      "node",
      "i",
      "length",
      "part",
      "nextNode",
      "undefined",
      "Object",
      "create",
      "$",
      "lookupInTrie",
      "index",
      "publicSuffixIndex",
      "SuffixTrie",
      "rules",
      "exceptions",
      "exception",
      "fromJson",
      "json",
      "prototype",
      "hasTld",
      "value",
      "suffixLookup",
      "hostname",
      "split",
      "exceptionIndex",
      "slice",
      "join",
      "module",
      "exports"
    ],
    "sources": [
      "/Users/danielleflinn/Documents/GitHub/clients/node_modules/tldjs/lib/suffix-trie.js"
    ],
    "sourcesContent": [
      "\"use strict\";\n\nvar VALID_HOSTNAME_VALUE = 0;\n\n\n/**\n * Return min(a, b), handling possible `null` values.\n *\n * @param {number|null} a\n * @param {number|null} b\n * @return {number|null}\n */\nfunction minIndex(a, b) {\n  if (a === null) {\n    return b;\n  } else if (b === null) {\n    return a;\n  }\n\n  return a < b ? a : b;\n}\n\n\n/**\n * Insert a public suffix rule in the `trie`.\n *\n * @param {object} rule\n * @param {object} trie\n * @return {object} trie (updated)\n */\nfunction insertInTrie(rule, trie) {\n  var parts = rule.parts;\n  var node = trie;\n\n  for (var i = 0; i < parts.length; i += 1) {\n    var part = parts[i];\n    var nextNode = node[part];\n    if (nextNode === undefined) {\n      nextNode = Object.create(null);\n      node[part] = nextNode;\n    }\n\n    node = nextNode;\n  }\n\n  node.$ = VALID_HOSTNAME_VALUE;\n\n  return trie;\n}\n\n\n/**\n * Recursive lookup of `parts` (starting at `index`) in the tree.\n *\n * @param {array} parts\n * @param {object} trie\n * @param {number} index - when to start in `parts` (initially: length - 1)\n * @return {number} size of the suffix found (in number of parts matched)\n */\nfunction lookupInTrie(parts, trie, index) {\n  var part;\n  var nextNode;\n  var publicSuffixIndex = null;\n\n  // We have a match!\n  if (trie.$ !== undefined) {\n    publicSuffixIndex = index + 1;\n  }\n\n  // No more `parts` to look for\n  if (index === -1) {\n    return publicSuffixIndex;\n  }\n\n  part = parts[index];\n\n  // Check branch corresponding to next part of hostname\n  nextNode = trie[part];\n  if (nextNode !== undefined) {\n    publicSuffixIndex = minIndex(\n      publicSuffixIndex,\n      lookupInTrie(parts, nextNode, index - 1)\n    );\n  }\n\n  // Check wildcard branch\n  nextNode = trie['*'];\n  if (nextNode !== undefined) {\n    publicSuffixIndex = minIndex(\n      publicSuffixIndex,\n      lookupInTrie(parts, nextNode, index - 1)\n    );\n  }\n\n  return publicSuffixIndex;\n}\n\n\n/**\n * Contains the public suffix ruleset as a Trie for efficient look-up.\n *\n * @constructor\n */\nfunction SuffixTrie(rules) {\n  this.exceptions = Object.create(null);\n  this.rules = Object.create(null);\n\n  if (rules) {\n    for (var i = 0; i < rules.length; i += 1) {\n      var rule = rules[i];\n      if (rule.exception) {\n        insertInTrie(rule, this.exceptions);\n      } else {\n        insertInTrie(rule, this.rules);\n      }\n    }\n  }\n}\n\n\n/**\n * Load the trie from JSON (as serialized by JSON.stringify).\n */\nSuffixTrie.fromJson = function (json) {\n  var trie = new SuffixTrie();\n\n  trie.exceptions = json.exceptions;\n  trie.rules = json.rules;\n\n  return trie;\n};\n\n\n/**\n * Check if `value` is a valid TLD.\n */\nSuffixTrie.prototype.hasTld = function (value) {\n  // All TLDs are at the root of the Trie.\n  return this.rules[value] !== undefined;\n};\n\n\n/**\n * Check if `hostname` has a valid public suffix in `trie`.\n *\n * @param {string} hostname\n * @return {string|null} public suffix\n */\nSuffixTrie.prototype.suffixLookup = function (hostname) {\n  var parts = hostname.split('.');\n\n  // Look for a match in rules\n  var publicSuffixIndex = lookupInTrie(\n    parts,\n    this.rules,\n    parts.length - 1\n  );\n\n  if (publicSuffixIndex === null) {\n    return null;\n  }\n\n  // Look for exceptions\n  var exceptionIndex = lookupInTrie(\n    parts,\n    this.exceptions,\n    parts.length - 1\n  );\n\n  if (exceptionIndex !== null) {\n    return parts.slice(exceptionIndex + 1).join('.');\n  }\n\n  return parts.slice(publicSuffixIndex).join('.');\n};\n\n\nmodule.exports = SuffixTrie;\n"
    ],
    "mappings": "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"
  },
  "metadata": {},
  "sourceType": "script"
}
